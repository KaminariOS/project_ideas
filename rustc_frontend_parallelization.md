
[从 Rust 并行编译到语言社区技术演进](https://www.bilibili.com/video/BV11ZnbzZE8q)

# 🦀 Rust 并行编译、编译性能与语言特性演进 —— 内容总结

## 1. 背景与演讲动机

* 演讲者自 2020 年加入华为 & Rust 社区，从标准库 SIMD 到编译器，再到并行编译 maintainer 与工作组 leader。
* 内容源自去年 RustConf 的延展：一年内有更多经验、故事及技术进展。
* Rust 的发展不仅是编译性能问题，也是整体易用性、性能、安全性等综合演进。

---

# 2. Rust 编译慢的根本原因

### 2.1 语言特性导致的天然开销

* **泛型单态化（monomorphization）**：每个实例化都生成独立代码 → 编译量大（类似 C++ 模板）。
* **基于查询（query-based）编译架构**：复杂的 DAG 调度，调用次数巨大。
* **Borrow Check、宏展开等特性**：安全性高但编译代价大。

### 2.2 实测问题

* 大项目规模下编译时间呈指数式增长，相比 C++ 成倍增加。
* 社区对性能高度敏感，所有 PR 都跑编译器基准。

---

# 3. Rust 编译性能提升的已有成果

### 3.1 整体趋势

* 从 Rust 1.28 到当前版本，平均编译性能提升近一倍。
* 特殊事件：1.53 增量编译毁灭性回退（因重大 bug 被迫禁用）。

### 3.2 常见优化手段

1. **PGO（Profile-Guided Optimization）**
2. **BOLT**
3. **ThinLTO（取代某些项目错误开启的 Full LTO）**
4. **更快的链接器**

   * Linux Rust 默认已切换到 **LLD**，平均加速约 **40%**
   * 还有 mold、parallel link 等更快方案可尝试

---

# 4. Rust 并行编译（Parallel Compilation）

Rust 编译器本身的内部流程高度串行化，前端部分长期无法并行。

并行编译目的：
**不仅 Crate-level 并行（cargo）要快，单个 crate 内部（函数、类型检查、HIR、宏等）也要并行。**

---

## 5. 并行编译的历史

* **2018–2019**：设计提出 → 工作组成立 → 遭遇瓶颈 → 停滞

  * 最大瓶颈：并行实现导致单线程性能下降 10–30%，社区无法接受
* **2022**：演讲者重新接手方案，重构数据结构 → 找到突破口
* **2023–2024**：进入 nightly → 大量 bug 处理（死锁、cache 冲突）
* **2024–2025**：打磨最后的 20%（最难的部分）

---

# 6. 技术核心：如何保证并行与单线程性能都不退化

## 6.1 双模式数据结构（关键创新）

类似“城市里既有公路又有铁路”的类比：

* 单线程模式：使用 `RefCell` 等轻量结构（高性能）
* 多线程模式：使用锁（线程安全）
* 启动时通过一个总开关决定使用哪套结构

让 Rust 编译器在：

* 单线程：保持原性能
* 多线程：安全执行

---

# 7. 并行实现中的关键挑战与解决策略

## 7.1 内存分配热点

* 多线程争抢同一分配器 → 严重瓶颈
  **解决：**线程本地内存池（TLS allocator）

## 7.2 查询系统（queries）缓存争用

* 所有线程都往统一缓存写结果 → 热点
  **解决：**将缓存分片（按 key hash 等）。

## 7.3 死锁（最困难的问题）

* Rayon's work-stealing 在存在依赖的任务图中会死锁
* 任务 A 等 B，B 又放下任务去偷别人的，循环等待

**解决：**

* 修改底层调度策略：某些场景不允许偷任务，必须继续原任务或睡眠等待
* 本质是约束工作窃取逻辑 → 今年才稳定合入

## 7.4 二进制一致性（determinism）

* 宏展开顺序在并行环境中不再稳定 → 二进制不一致
* 仍在研究中（棘手问题）

---

# 8. 仍未解决的串行环节

如：

* 宏展开（expand）顺序对结果有影响 → 难以并行
* HIR 生成依赖单一 global 存储结构（类似所有人都只能去一个派出所办证）

这些将决定并行编译能否进一步突破。

---

# 9. 未来的编译性能方向

1. **更快的链接器（mold、parallel mold）**
2. **增量编译的现代化重做**
3. **跨 crate trait 解析复用（inter-crate trait sharing）**
4. **将查询本身异步化（async queries）**

---

# 10. Rust 易用性方向（语法与语言特性）

为降低学习门槛、提升开发体验：

### 10.1 async 生态增强

* async trait
* async fn in trait
* 更好的协程语义（如 C++20 co_await 的类似能力）

### 10.2 delegation（委托）

* 组合替代继承，但组合的 ergonomics 需要语言特性支持。

### 10.3 生命周期更友好

* lifetime 省略规则增强（赵澈负责的方向）

### 10.4 in-place initialization（就地初始化）

* 不再需要写一堆 `new()`；结构体创建时直接初始化

### 10.5 Rust/C++ 混编能力（Google 投资 100 万美元）

* 社区方案：统一通过 C API 层进行绑定
* 推荐：HICC（演讲者同事提出）

---

# 11. 总结

Rust 编译器并行化：

* **设计简单，工程极度复杂**
* 解决了体系结构、内存模型、并发模型、调度算法等全链路问题
* 仍在演进，未来两年会持续带来巨额性能收益

Rust 语言本身：

* 性能以外，现在更关注**易用性、可扩展性、与工业级需求的对接**

---

如果你想要，我可以继续输出：

### ✔ PPT 格式（每页内容 3–6  bullet）

### ✔ 演讲稿格式（10 分钟/20 分钟/40 分钟版本）

### ✔ 面向 Rust 编译器开发者的深度技术笔记

### ✔ 面向管理层/产品的非技术总结

告诉我即可。
